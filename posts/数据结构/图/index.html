<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>图 - Riddle&#39;s Notebook</title><meta name="Description" content=""><meta property="og:title" content="图" />
<meta property="og:description" content="图 1. 定义 图G由顶点集V和边集E组成，记作G = (V, E)其中V(G)表示图G中顶点的有限非空集, E(G)表示图G中顶点之间的关系(边)集合|V|表" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://maoqiankun97.github.io/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-15T20:30:02&#43;08:00" />
<meta property="article:modified_time" content="2021-03-15T20:30:02&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="图"/>
<meta name="twitter:description" content="图 1. 定义 图G由顶点集V和边集E组成，记作G = (V, E)其中V(G)表示图G中顶点的有限非空集, E(G)表示图G中顶点之间的关系(边)集合|V|表"/>
<meta name="application-name" content="Riddle&#39;s Notebook">
<meta name="apple-mobile-web-app-title" content="Riddle&#39;s Notebook"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://maoqiankun97.github.io/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/" /><link rel="prev" href="https://maoqiankun97.github.io/posts/redis/redis_java%E5%AE%A2%E6%88%B7%E7%AB%AF-jedis/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "图",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/maoqiankun97.github.io\/posts\/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\/%E5%9B%BE\/"
        },"genre": "posts","keywords": "数据结构","wordcount":  7286 ,
        "url": "https:\/\/maoqiankun97.github.io\/posts\/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\/%E5%9B%BE\/","datePublished": "2021-03-15T20:30:02+08:00","dateModified": "2021-03-15T20:30:02+08:00","publisher": {
            "@type": "Organization",
            "name": "Riddle"},"author": {
                "@type": "Person",
                "name": "Riddle"
            },"description": ""
    }
    </script></head>
    <body header-desktop="" header-mobile=""><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : '' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Riddle&#39;s Notebook">Riddle&#39;s Notebook</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Riddle&#39;s Notebook">Riddle&#39;s Notebook</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">图</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/posts/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>Riddle</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><i class="far fa-folder fa-fw"></i>数据结构</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-03-15">2021-03-15</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 7286 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 15 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#1-定义">1. 定义</a>
      <ul>
        <li><a href="#11-简单图">1.1 简单图</a></li>
        <li><a href="#12-多重图">1.2 多重图</a></li>
        <li><a href="#13-完全图">1.3 完全图</a></li>
        <li><a href="#14-子图与生成子图">1.4 子图与生成子图</a></li>
        <li><a href="#15-连通与强连通">1.5 连通与强连通</a></li>
        <li><a href="#16-连通图与强连通图">1.6 连通图与强连通图</a></li>
        <li><a href="#17-连通分量与强连通分量">1.7 连通分量与强连通分量</a></li>
        <li><a href="#18-生成树与生成森林">1.8 生成树与生成森林</a></li>
        <li><a href="#19-顶点的度">1.9 顶点的度</a></li>
        <li><a href="#110-网">1.10 网</a></li>
        <li><a href="#111-稠密图与稀疏图">1.11 稠密图与稀疏图</a></li>
        <li><a href="#112-有向树">1.12 有向树</a></li>
        <li><a href="#113-路径">1.13 路径</a></li>
        <li><a href="#114-路径长度">1.14 路径长度</a></li>
        <li><a href="#115-回路">1.15 回路</a></li>
      </ul>
    </li>
    <li><a href="#2-基本操作">2. 基本操作</a>
      <ul>
        <li><a href="#21-adjacentg-x-y">2.1 Adjacent(G, x, y)</a></li>
        <li><a href="#22-neighborsg-x">2.2 Neighbors(G, x)</a></li>
        <li><a href="#23-insertvertexg-x">2.3 InsertVertex(G, x)</a></li>
        <li><a href="#24-deletevertexg-x">2.4 DeleteVertex(G, x)</a></li>
        <li><a href="#25-addedgeg-x-y">2.5 AddEdge(G, x, y)</a></li>
        <li><a href="#26-removeedgeg-x-y">2.6 RemoveEdge(G, x, y)</a></li>
        <li><a href="#27-firstneighborg-x">2.7 FirstNeighbor(G, x)</a></li>
        <li><a href="#28-nextneighborsg-x-y">2.8 NextNeighbors(G， x, y)</a></li>
      </ul>
    </li>
    <li><a href="#3-存储结构">3. 存储结构</a>
      <ul>
        <li><a href="#31-邻接矩阵法">3.1 邻接矩阵法</a></li>
        <li><a href="#32-邻接表法">3.2 邻接表法</a></li>
        <li><a href="#33-十字链表法">3.3 十字链表法</a></li>
        <li><a href="#34-邻接多重表法">3.4 邻接多重表法</a></li>
      </ul>
    </li>
    <li><a href="#4-常用算法">4. 常用算法</a>
      <ul>
        <li><a href="#41-广度优先搜索">4.1 广度优先搜索</a></li>
        <li><a href="#42-深度优先搜索">4.2 深度优先搜索</a></li>
        <li><a href="#43-最小生成树算法">4.3 最小生成树算法</a></li>
        <li><a href="#44-最短路径算法">4.4 最短路径算法</a></li>
        <li><a href="#44-拓扑排序">4.4 拓扑排序</a></li>
        <li><a href="#45-关键路径">4.5 关键路径</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="图">图</h1>
<h2 id="1-定义">1. 定义</h2>
<p>图G由顶点集V和边集E组成，记作G = (V, E)<!-- raw HTML omitted -->
其中V(G)表示图G中顶点的有限非空集, E(G)表示图G中顶点之间的关系(边)集合<!-- raw HTML omitted -->
|V|表示图中顶点个数，也称为图G的阶<!-- raw HTML omitted -->
|E|表示图中边的条数
<!-- raw HTML omitted -->
例：<!-- raw HTML omitted -->
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="%e5%9b%be1.1.png"
        data-srcset="%e5%9b%be1.1.png, %e5%9b%be1.1.png 1.5x, %e5%9b%be1.1.png 2x"
        data-sizes="auto"
        alt="图1.1.png"
        title="图1.1" />
<!-- raw HTML omitted -->
V(G) = {A, B, C, D, E}<!-- raw HTML omitted -->
E(G) = {(A, B), (A, C), (A, D), (B, C), (C, E), (C, D)} <!-- raw HTML omitted -->
|V| = 5 <!-- raw HTML omitted -->
|E| = 6</p>
<h3 id="11-简单图">1.1 简单图</h3>
<p>无重复边且不存在结点到自身的边的图</p>
<h3 id="12-多重图">1.2 多重图</h3>
<p>非简单图</p>
<h3 id="13-完全图">1.3 完全图</h3>
<h4 id="131-无向完全图">1.3.1 无向完全图</h4>
<p>任意两个顶点之间都存在边</p>
<h4 id="132-有向完全图">1.3.2 有向完全图</h4>
<p>任意两个顶点之间都存在方向相反的弧</p>
<h3 id="14-子图与生成子图">1.4 子图与生成子图</h3>
<h4 id="141-子图">1.4.1 子图</h4>
<p>子图定义: G'=(V', E'), G=(V, E), 其中V&rsquo;是V的子集, E&rsquo;是E的子集, 则称G&rsquo;是G的子图<!-- raw HTML omitted --></p>
<h4 id="142-生成子图">1.4.2 生成子图</h4>
<p>生成子图: 当G'=(V', E')是G=(V, E)的子图, 且V'=V, 则称G&rsquo;是G的生成子图</p>
<h3 id="15-连通与强连通">1.5 连通与强连通</h3>
<h4 id="151-连通">1.5.1 连通</h4>
<p>连通是一个针对无向图的概念，从顶点V到顶点W之间有路径存在，则称V和W是连通的。如：V &mdash; O &mdash; W</p>
<h4 id="152-强连通">1.5.2 强连通</h4>
<p>强连通是一个针对有向图的概念，从顶点V到顶点W和从顶点W到顶点V之间都有路径，则称V和W是强连通的。如：<!-- raw HTML omitted --></p>
<pre><code>V ---&gt; O ---&gt; W
^             |
|             |
L ------------|
</code></pre><h3 id="16-连通图与强连通图">1.6 连通图与强连通图</h3>
<h4 id="161-连通图">1.6.1 连通图</h4>
<p>对于无向图，任意两个顶点之间都是连通的，则称该无向图为连通图</p>
<ul>
<li>n个顶点的强连通图至少有n-1条边</li>
</ul>
<h4 id="162-强连通图">1.6.2 强连通图</h4>
<p>对于有向图，任意两个顶点之间都是强连通的，则称该有向图为强连通图</p>
<ul>
<li>n个顶点的强连通图至少有n条边</li>
</ul>
<h3 id="17-连通分量与强连通分量">1.7 连通分量与强连通分量</h3>
<p>对于G的一个(强)连通子图G'，若不存在G的另一个(强)连通子图G''，使得G' ⊂ G''，则称G&rsquo;是G的(强)连通分量</p>
<h3 id="18-生成树与生成森林">1.8 生成树与生成森林</h3>
<h4 id="181-极小连通子图">1.8.1 极小连通子图</h4>
<p>极小连通子图即包含边最少的连通子图</p>
<h4 id="182-生成树">1.8.2 生成树</h4>
<p>G是一个连通图，其包含G所有顶点的极小连通子图称作生成树</p>
<h4 id="183-生成森林">1.8.3 生成森林</h4>
<p>G是一个非连通图，其所有连通分量的生成树组成了其生成森林</p>
<h3 id="19-顶点的度">1.9 顶点的度</h3>
<h4 id="191-无向图">1.9.1 无向图</h4>
<p>以V为端点的边的数量，记作TD(V)</p>
<h4 id="192-有向图">1.9.2 有向图</h4>
<p>以V为起点的有向边的数量，记作OD(V)<!-- raw HTML omitted -->
以V为终点的有向边的数量，记作ID(V)<!-- raw HTML omitted -->
TD(V) = OD(V) + ID(V)</p>
<h3 id="110-网">1.10 网</h3>
<p>边有权重的图称作网</p>
<h3 id="111-稠密图与稀疏图">1.11 稠密图与稀疏图</h3>
<p>边多的图称为稠密图，反之边少的图称为稀疏图。具体的界限没有定义</p>
<h3 id="112-有向树">1.12 有向树</h3>
<p>一个顶点入度为0，其余顶点入度为1的有向图</p>
<h3 id="113-路径">1.13 路径</h3>
<p>从顶点V到顶点W的顶点序列<!-- raw HTML omitted -->
序列中顶点不重复的路径被称为简单路径</p>
<h3 id="114-路径长度">1.14 路径长度</h3>
<p>路径上边的长度</p>
<h3 id="115-回路">1.15 回路</h3>
<p>第一个顶点与最后一个顶点相同的路径</p>
<h2 id="2-基本操作">2. 基本操作</h2>
<h3 id="21-adjacentg-x-y">2.1 Adjacent(G, x, y)</h3>
<p>判断G中是否存在&lt;x, y&gt;或(x, y)</p>
<h3 id="22-neighborsg-x">2.2 Neighbors(G, x)</h3>
<p>列出G中与x邻接的顶点集合</p>
<h3 id="23-insertvertexg-x">2.3 InsertVertex(G, x)</h3>
<p>在图G中插入顶点x</p>
<h3 id="24-deletevertexg-x">2.4 DeleteVertex(G, x)</h3>
<p>在图G中删除顶点x</p>
<h3 id="25-addedgeg-x-y">2.5 AddEdge(G, x, y)</h3>
<p>若(x, y)或&lt;x, y&gt;不存在，添加</p>
<h3 id="26-removeedgeg-x-y">2.6 RemoveEdge(G, x, y)</h3>
<p>若(x, y)或&lt;x, y&gt;存在，删除</p>
<h3 id="27-firstneighborg-x">2.7 FirstNeighbor(G, x)</h3>
<p>求图G中与x邻接的第一个顶点</p>
<h3 id="28-nextneighborsg-x-y">2.8 NextNeighbors(G， x, y)</h3>
<p>求图G中x除y之外的下一个邻接顶点</p>
<h2 id="3-存储结构">3. 存储结构</h2>
<h3 id="31-邻接矩阵法">3.1 邻接矩阵法</h3>
<h4 id="311-定义">3.1.1 定义</h4>
<p>|V| = n的图，邻接矩阵A为n*n<!-- raw HTML omitted -->
设V的编号为v1、v2、&hellip;、vn
若&lt;vi, vj&gt; ∈ E, 则A[i][j] = 1，否则A[i][j] = 0或正无穷 (对于网，A[i][j]表示权重);</p>
<ul>
<li>对于图G的邻接矩阵A， A^n的含义：A^n[i][j]表示从顶点vi到顶点vj长度为n的路径条数</li>
</ul>
<p>例:<!-- raw HTML omitted -->
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="%e5%9b%be1.1.png"
        data-srcset="%e5%9b%be1.1.png, %e5%9b%be1.1.png 1.5x, %e5%9b%be1.1.png 2x"
        data-sizes="auto"
        alt="图1.1.png"
        title="图1.1" /></p>
<p>将A编号为0~E编号为4
其邻接矩阵为</p>
<pre><code>0 1 1 1 - 
1 0 1 - - 
1 1 0 1 1 
1 - 1 0 - 
- - 1 - 0
</code></pre><h4 id="312-存储结构代码实现">3.1.2 存储结构代码实现</h4>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="nc">MatrixGraph</span> <span class="p">{</span>
    <span class="c1">// 顶点集合, 下标代表顶点的序号, 对应下标的值代表顶点的值, 为了简单, 限定顶点值只能为A~Z
</span><span class="c1"></span>    <span class="kt">char</span> <span class="n">V</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span>
    <span class="c1">// 顶点位置, 即顶点在邻接矩阵中的下标
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">vertexLocation</span><span class="p">[</span><span class="mi">26</span><span class="p">];</span>
    <span class="c1">// 顶点数量
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">vertexNum</span><span class="p">;</span>
    <span class="c1">// 邻接矩阵
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">A</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">][</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span>
    <span class="c1">// 边的数量
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">edgeNum</span><span class="p">;</span>
    <span class="c1">// 是否为有向图
</span><span class="c1"></span>    <span class="kt">bool</span> <span class="n">directed</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div><h4 id="313-基本操作实现">3.1.3 基本操作实现</h4>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">bool</span> <span class="nf">CreateGraph</span><span class="p">(</span><span class="n">MatrixGraph</span> <span class="o">*&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v_num</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">v</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">e_num</span><span class="p">,</span> <span class="kt">char</span> <span class="n">e</span><span class="p">[][</span><span class="mi">2</span><span class="p">],</span> <span class="kt">bool</span> <span class="n">directed</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v_num</span> <span class="o">&gt;</span> <span class="n">MAX_VERTEX_NUM</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">G</span> <span class="o">=</span> <span class="p">(</span><span class="n">MatrixGraph</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">MatrixGraph</span><span class="p">));</span>
    <span class="n">G</span><span class="o">-&gt;</span><span class="n">directed</span> <span class="o">=</span> <span class="n">directed</span><span class="p">;</span>
    <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span> <span class="o">=</span> <span class="n">v_num</span><span class="p">;</span>
    <span class="n">G</span><span class="o">-&gt;</span><span class="n">edgeNum</span> <span class="o">=</span> <span class="n">e_num</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexLocation</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexLocation</span><span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">v_num</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">e_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">InsertEdge</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">DestroyGraph</span><span class="p">(</span><span class="n">MatrixGraph</span> <span class="o">*&amp;</span><span class="n">G</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">LocateVex</span><span class="p">(</span><span class="n">MatrixGraph</span> <span class="o">*</span><span class="n">G</span><span class="p">,</span> <span class="kt">char</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">return</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexLocation</span><span class="p">[</span><span class="n">v</span> <span class="o">-</span> <span class="sc">&#39;A&#39;</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">FirstAdjVex</span><span class="p">(</span><span class="n">MatrixGraph</span> <span class="o">*</span><span class="n">G</span><span class="p">,</span> <span class="kt">char</span> <span class="n">v</span><span class="p">,</span> <span class="kt">char</span> <span class="o">&amp;</span><span class="n">adjVex</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">v_index</span> <span class="o">=</span> <span class="n">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">v_index</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">v_index</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">adjVex</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">NextAdjVex</span><span class="p">(</span><span class="n">MatrixGraph</span> <span class="o">*</span><span class="n">G</span><span class="p">,</span> <span class="kt">char</span> <span class="n">v</span><span class="p">,</span> <span class="kt">char</span> <span class="n">w</span><span class="p">,</span> <span class="kt">char</span> <span class="o">&amp;</span><span class="n">nextAdjVex</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">v_index</span> <span class="o">=</span> <span class="n">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">w_index</span> <span class="o">=</span> <span class="n">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">w_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">v_index</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">v_index</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">nextAdjVex</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">InsertVex</span><span class="p">(</span><span class="n">MatrixGraph</span> <span class="o">*&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">char</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span> <span class="o">&gt;=</span> <span class="n">MAX_VERTEX_NUM</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexLocation</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">G</span><span class="o">-&gt;</span><span class="n">V</span><span class="p">[</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexLocation</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="p">;</span>
    <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="o">++</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">DeleteVex</span><span class="p">(</span><span class="n">MatrixGraph</span> <span class="o">*&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">char</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">v_index</span> <span class="o">=</span> <span class="n">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexLocation</span><span class="p">[</span><span class="n">v</span> <span class="o">-</span> <span class="sc">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">flag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_VERTEX_NUM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">MAX_VERTEX_NUM</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">G</span><span class="o">-&gt;</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">V</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="o">--</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_VERTEX_NUM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">directed</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">v_index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">v_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
                <span class="n">G</span><span class="o">-&gt;</span><span class="n">edgeNum</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">v_index</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">v_index</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
                <span class="n">G</span><span class="o">-&gt;</span><span class="n">edgeNum</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">v_index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">v_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
                <span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">v_index</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
                <span class="n">G</span><span class="o">-&gt;</span><span class="n">edgeNum</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">InsertEdge</span><span class="p">(</span><span class="n">MatrixGraph</span> <span class="o">*&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">char</span> <span class="n">v</span><span class="p">,</span> <span class="kt">char</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">v_index</span> <span class="o">=</span> <span class="n">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">w_index</span> <span class="o">=</span> <span class="n">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">w_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">directed</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">v_index</span><span class="p">][</span><span class="n">w_index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">v_index</span><span class="p">][</span><span class="n">w_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">edgeNum</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">v_index</span><span class="p">][</span><span class="n">w_index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">v_index</span><span class="p">][</span><span class="n">w_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">w_index</span><span class="p">][</span><span class="n">v_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">edgeNum</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">DeleteEdge</span><span class="p">(</span><span class="n">MatrixGraph</span> <span class="o">*&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">char</span> <span class="n">v</span><span class="p">,</span> <span class="kt">char</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">v_index</span> <span class="o">=</span> <span class="n">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">w_index</span> <span class="o">=</span> <span class="n">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">w_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">directed</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">v_index</span><span class="p">][</span><span class="n">w_index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">v_index</span><span class="p">][</span><span class="n">w_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">edgeNum</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">v_index</span><span class="p">][</span><span class="n">w_index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">v_index</span><span class="p">][</span><span class="n">w_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">w_index</span><span class="p">][</span><span class="n">v_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">edgeNum</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="32-邻接表法">3.2 邻接表法</h3>
<h4 id="321-定义">3.2.1 定义</h4>
<p>邻接表(Adjacency List)是图的一种链式存储结构。对图中每个顶点，设立一个表头结点，在表头结点中有两个域:顶点信息域(data)和指向其关联的边的域(firstarc)指向其边表链表结点。vi的边表链表中的一个结点表示依附于顶点vi的边(对于有向图则是以vi为尾的弧)，每个链表结点由2个域组成，其中邻接点域(adjvex)表示与顶点vi邻接的点在图中的位置，链域(nextarc)指示下一条边或弧的链表结点。如果边有权重等信息，可额外添加域来存储信息。</p>
<p>例:<!-- raw HTML omitted -->
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="%e5%9b%be1.1.png"
        data-srcset="%e5%9b%be1.1.png, %e5%9b%be1.1.png 1.5x, %e5%9b%be1.1.png 2x"
        data-sizes="auto"
        alt="图1.1.png"
        title="图1.1" /></p>
<p>将A编号为0~E编号为4
其邻接表为
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="%e9%82%bb%e6%8e%a5%e8%a1%a8%e5%ad%98%e5%82%a8.png"
        data-srcset="%e9%82%bb%e6%8e%a5%e8%a1%a8%e5%ad%98%e5%82%a8.png, %e9%82%bb%e6%8e%a5%e8%a1%a8%e5%ad%98%e5%82%a8.png 1.5x, %e9%82%bb%e6%8e%a5%e8%a1%a8%e5%ad%98%e5%82%a8.png 2x"
        data-sizes="auto"
        alt="邻接表存储.png"
        title="邻接表存储" /></p>
<h4 id="322-存储结构代码实现">3.2.2 存储结构代码实现</h4>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// 边表结点
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">ArcNode</span> <span class="p">{</span>
    <span class="c1">// 边表另一个顶点在图中的下标
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">adjVexIndex</span><span class="p">;</span>

    <span class="k">struct</span> <span class="nc">ArcNode</span> <span class="o">*</span><span class="n">nextArc</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 顶点结点
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">VNode</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">data</span><span class="p">;</span>

    <span class="k">struct</span> <span class="nc">ArcNode</span> <span class="o">*</span><span class="n">firstArc</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="nc">AdjListGraph</span> <span class="p">{</span>
    <span class="n">VNode</span> <span class="o">*</span><span class="n">vertex</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span>
    <span class="c1">// 顶点位置, 即顶点在邻接矩阵中的下标
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">vertexLocation</span><span class="p">[</span><span class="mi">26</span><span class="p">];</span>
    <span class="c1">// 顶点数量
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">vertexNum</span><span class="p">;</span>
    <span class="c1">// 边的数量
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">edgeNum</span><span class="p">;</span>
    <span class="c1">// 是否为有向图
</span><span class="c1"></span>    <span class="kt">bool</span> <span class="n">directed</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div><h4 id="323-基本操作实现">3.2.3 基本操作实现</h4>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">bool</span> <span class="nf">CreateGraph</span><span class="p">(</span><span class="n">AdjListGraph</span> <span class="o">*&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v_num</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">v</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">e_num</span><span class="p">,</span> <span class="kt">char</span> <span class="n">e</span><span class="p">[][</span><span class="mi">2</span><span class="p">],</span> <span class="kt">bool</span> <span class="n">directed</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v_num</span> <span class="o">&gt;</span> <span class="n">MAX_VERTEX_NUM</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">G</span> <span class="o">=</span> <span class="p">(</span><span class="n">AdjListGraph</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">AdjListGraph</span><span class="p">));</span>
    <span class="n">G</span><span class="o">-&gt;</span><span class="n">directed</span> <span class="o">=</span> <span class="n">directed</span><span class="p">;</span>
    <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span> <span class="o">=</span> <span class="n">v_num</span><span class="p">;</span>
    <span class="n">G</span><span class="o">-&gt;</span><span class="n">edgeNum</span> <span class="o">=</span> <span class="n">e_num</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexLocation</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">VNode</span> <span class="o">*</span><span class="n">vnode</span> <span class="o">=</span> <span class="p">(</span><span class="n">VNode</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">VNode</span><span class="p">));</span>
        <span class="n">vnode</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">vnode</span><span class="o">-&gt;</span><span class="n">firstArc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vnode</span><span class="p">;</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexLocation</span><span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">e_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">InsertEdge</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">LocateVex</span><span class="p">(</span><span class="n">AdjListGraph</span> <span class="o">*</span><span class="n">G</span><span class="p">,</span> <span class="kt">char</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">return</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexLocation</span><span class="p">[</span><span class="n">v</span> <span class="o">-</span> <span class="sc">&#39;A&#39;</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">InsertEdge</span><span class="p">(</span><span class="n">AdjListGraph</span> <span class="o">*&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">char</span> <span class="n">v</span><span class="p">,</span> <span class="kt">char</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">v_index</span> <span class="o">=</span> <span class="n">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">w_index</span> <span class="o">=</span> <span class="n">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">w_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">directed</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ArcNode</span><span class="o">*</span> <span class="n">tailArch</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">ArcNode</span><span class="o">*</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">v_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">firstArc</span><span class="p">;</span> <span class="n">arc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">arc</span><span class="o">-&gt;</span><span class="n">nextArc</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span> <span class="o">==</span> <span class="n">w_index</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">tailArch</span> <span class="o">=</span> <span class="n">arc</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ArcNode</span> <span class="o">*</span><span class="n">arcNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">ArcNode</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ArcNode</span><span class="p">));</span>
        <span class="n">arcNode</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
        <span class="n">arcNode</span><span class="o">-&gt;</span><span class="n">nextArc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">tailArch</span><span class="o">-&gt;</span><span class="n">nextArc</span> <span class="o">=</span> <span class="n">arcNode</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 插入v-w
</span><span class="c1"></span>        <span class="n">ArcNode</span><span class="o">*</span> <span class="n">tailArch</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">ArcNode</span><span class="o">*</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">v_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">firstArc</span><span class="p">;</span> <span class="n">arc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">arc</span><span class="o">-&gt;</span><span class="n">nextArc</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span> <span class="o">==</span> <span class="n">w_index</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">tailArch</span> <span class="o">=</span> <span class="n">arc</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ArcNode</span> <span class="o">*</span><span class="n">arcNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">ArcNode</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ArcNode</span><span class="p">));</span>
        <span class="n">arcNode</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span> <span class="o">=</span> <span class="n">w_index</span><span class="p">;</span>
        <span class="n">arcNode</span><span class="o">-&gt;</span><span class="n">nextArc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tailArch</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">v_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">firstArc</span> <span class="o">=</span> <span class="n">arcNode</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">tailArch</span><span class="o">-&gt;</span><span class="n">nextArc</span> <span class="o">=</span> <span class="n">arcNode</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 插入w-v
</span><span class="c1"></span>        <span class="n">tailArch</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">ArcNode</span><span class="o">*</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">w_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">firstArc</span><span class="p">;</span> <span class="n">arc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">arc</span><span class="o">-&gt;</span><span class="n">nextArc</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span> <span class="o">==</span> <span class="n">v_index</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">tailArch</span> <span class="o">=</span> <span class="n">arc</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">arcNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">ArcNode</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ArcNode</span><span class="p">));</span>
        <span class="n">arcNode</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span> <span class="o">=</span> <span class="n">v_index</span><span class="p">;</span>
        <span class="n">arcNode</span><span class="o">-&gt;</span><span class="n">nextArc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tailArch</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">w_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">firstArc</span> <span class="o">=</span> <span class="n">arcNode</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">tailArch</span><span class="o">-&gt;</span><span class="n">nextArc</span> <span class="o">=</span> <span class="n">arcNode</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">G</span><span class="o">-&gt;</span><span class="n">edgeNum</span><span class="o">++</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="33-十字链表法">3.3 十字链表法</h3>
<h3 id="34-邻接多重表法">3.4 邻接多重表法</h3>
<h2 id="4-常用算法">4. 常用算法</h2>
<h3 id="41-广度优先搜索">4.1 广度优先搜索</h3>
<ul>
<li>树的层次遍历即为广度优先搜索</li>
<li>广度优先生成树
从图的顶点v出发进行广度优先搜索的步骤为：</li>
</ul>
<ol>
<li>首先访问起始顶点v</li>
<li>由v出发，依次访问v的各个未被访问的邻接顶点w1、w2 &hellip; wi</li>
<li>依次访问w1、w2 &hellip; wi的所有未被访问过的邻接顶点</li>
<li>以此类推</li>
</ol>
<p>代码实现:</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * 广度优先搜索.
</span><span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">BFS</span><span class="p">(</span><span class="n">AdjListGraph</span> <span class="o">*</span><span class="n">G</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">visit</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">false</span><span class="p">};</span>
    <span class="c1">// 定义一个队列备用
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">queue</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">front</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">rear</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">visit</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 从i开始遍历
</span><span class="c1"></span>        <span class="c1">// 入队并将i设为将要访问
</span><span class="c1"></span>        <span class="n">visit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">queue</span><span class="p">[</span><span class="n">rear</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">rear</span> <span class="o">=</span> <span class="p">(</span><span class="n">rear</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">front</span> <span class="o">!=</span> <span class="n">rear</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 出队访问
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">queue_front</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="n">front</span><span class="p">];</span>
            <span class="n">front</span> <span class="o">=</span> <span class="p">(</span><span class="n">front</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">queue_front</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; - &#34;</span><span class="p">;</span>
            <span class="c1">// 其未被访问的邻接结点入队
</span><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">queue_front</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">firstArc</span><span class="p">;</span> <span class="n">arc</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">arc</span><span class="o">-&gt;</span><span class="n">nextArc</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">visit</span><span class="p">[</span><span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span><span class="p">])</span> <span class="p">{</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">rear</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="n">front</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// 队列已满
</span><span class="c1"></span>                    <span class="k">return</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">visit</span><span class="p">[</span><span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">queue</span><span class="p">[</span><span class="n">rear</span><span class="p">]</span> <span class="o">=</span> <span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span><span class="p">;</span>
                <span class="n">rear</span> <span class="o">=</span> <span class="p">(</span><span class="n">rear</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h3 id="42-深度优先搜索">4.2 深度优先搜索</h3>
<ul>
<li>树的先序遍历可以理解为深度优先搜索</li>
<li>深度优先生成树
从图的顶点v出发进行广度优先搜索的步骤为：</li>
</ul>
<ol>
<li>首先访问v</li>
<li>由v出发访问v的任意一个邻接且未被访问过的邻接顶点wi</li>
<li>在访问域wi邻接且未被访问过的顶点yi</li>
<li>若wi无邻接且未被访问的顶点，则退回到v</li>
<li>重复以上过程至所有顶点均被访问过</li>
</ol>
<p>代码实现:</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * 从指定的顶点开始深度优先搜索.
</span><span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">DFS_i</span><span class="p">(</span><span class="n">AdjListGraph</span> <span class="o">*</span><span class="n">G</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vertex_index</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">visit</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">// 开始由i开始遍历
</span><span class="c1"></span>    <span class="n">visit</span><span class="p">[</span><span class="n">vertex_index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">vertex_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; - &#34;</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">vertex_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">firstArc</span><span class="p">;</span> <span class="n">arc</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">arc</span><span class="o">-&gt;</span><span class="n">nextArc</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">visit</span><span class="p">[</span><span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">DFS_i</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span><span class="p">,</span> <span class="n">visit</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**
</span><span class="cm"> * 深度优先搜索.
</span><span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">DFS</span><span class="p">(</span><span class="n">AdjListGraph</span> <span class="o">*</span><span class="n">G</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">visit</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">false</span><span class="p">};</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">visit</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">DFS_i</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">visit</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="43-最小生成树算法">4.3 最小生成树算法</h3>
<p>对于带权无向连通图G=(V, E), G的所有生成树中边的权值之和最小的生成树为G的最小生成树(MST)，最小生成树有如下性质：</p>
<ul>
<li>最小生成树不一定唯一，对于每条边权重都不相同的情况一定是唯一的，对于G只有|V|-1条边是，MST也一定是唯一的</li>
<li>最小生成树的权值是唯一且相等的</li>
<li>最小生成树的边数为顶点数-1
大致算法思想:</li>
</ul>
<pre><code>GEN_MST(G)
    T = NULL;
    while T未形成一棵生成树
        找到一条最小代价边，且加入T后不会产生回路，设其为(u, v)
        T = T ∪ (u, v);
</code></pre><h4 id="431-prim算法">4.3.1 Prim算法</h4>
<h5 id="4311-流程描述">4.3.1.1 流程描述</h5>
<ol>
<li>初始化：向空的结果树T = (VT, ET)中添加G = (V, E)的任一顶点u0，使得VT = {u0}， ET = Ø</li>
<li>循环直到VT = V: 从G中选择满足{(u, v)|u∈VT， v∈V-VT}，且具有最小权值的边(u, v)，并置VT = VT ∪ {v}，ET = ET ∪ {(u, v)}</li>
</ol>
<h5 id="4312-具体实现">4.3.1.2 具体实现</h5>
<p>引入数组：<!-- raw HTML omitted -->
min_weight: 表示从已知顶点集VT到各顶点的最小权值<!-- raw HTML omitted -->
adjvex: 表示到达各顶点的最小权值的邻接顶点下标</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="%e5%b8%a6%e6%9d%83%e6%97%a0%e5%90%91%e5%9b%be.png"
        data-srcset="%e5%b8%a6%e6%9d%83%e6%97%a0%e5%90%91%e5%9b%be.png, %e5%b8%a6%e6%9d%83%e6%97%a0%e5%90%91%e5%9b%be.png 1.5x, %e5%b8%a6%e6%9d%83%e6%97%a0%e5%90%91%e5%9b%be.png 2x"
        data-sizes="auto"
        alt="带权无向图.png"
        title="带权无向图" /></p>
<ol>
<li>取A, 初始化数组:</li>
</ol>
<table>
<thead>
<tr>
<th>数组名</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>min_weight</td>
<td>0</td>
<td>3</td>
<td>1</td>
<td>INF</td>
<td>4</td>
</tr>
<tr>
<td>adjvex</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>取min(min_weight), 得 1 对应的边为 (A, C)，满足{(u, v)|u∈VT， v∈V-VT}（判断方法为min_weight[2] != 0），则min_weight[2] = 0，并更新数组</li>
</ol>
<table>
<thead>
<tr>
<th>数组名</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>min_weight</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>5</td>
<td>4</td>
</tr>
<tr>
<td>adjvex</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>0</td>
</tr>
</tbody>
</table>
<ol start="3">
<li>取min(min_weight), 得 2 对应的边为 (C, B)，满足{(u, v)|u∈VT， v∈V-VT}（判断方法为min_weight[1] != 0），则min_weight[1] = 0，并更新数组</li>
</ol>
<table>
<thead>
<tr>
<th>数组名</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>min_weight</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>5</td>
<td>4</td>
</tr>
<tr>
<td>adjvex</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>0</td>
</tr>
</tbody>
</table>
<ol start="4">
<li>取min(min_weight), 得 4 对应的边为 (A, E)，满足{(u, v)|u∈VT， v∈V-VT}（判断方法为min_weight[4] != 0），则min_weight[4] = 0，并更新数组</li>
</ol>
<table>
<thead>
<tr>
<th>数组名</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>min_weight</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>5</td>
<td>0</td>
</tr>
<tr>
<td>adjvex</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>0</td>
</tr>
</tbody>
</table>
<ol start="5">
<li>取min(min_weight), 得 5 对应的边为 (C, D)，满足{(u, v)|u∈VT， v∈V-VT}（判断方法为min_weight[3] != 0），则min_weight[3] = 0，并更新数组</li>
</ol>
<table>
<thead>
<tr>
<th>数组名</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>min_weight</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>adjvex</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>0</td>
</tr>
</tbody>
</table>
<h4 id="432-kruskal算法">4.3.2 Kruskal算法</h4>
<h5 id="4321-流程描述">4.3.2.1 流程描述</h5>
<ol>
<li>初始化: VT = V; ET = Ø</li>
<li>循环：按G的边权值递增一次从E-ET中选择边，若其加入后不构成回路，将其加入ET中，否则舍弃，直到|ET| = |V| - 1</li>
</ol>
<pre><code>MST_Kruskal(G, DSU)
    sort(G.edges)
    Init(DSU)
    for i = 0...G.edges.length
        if DSU.isSameGroup(edges[i].a, edges[i].b)
            continue;
        ET = ET ∪ {edges[i]}
        DSU.union(edges[i].a, edges[i].b)
</code></pre><h5 id="4322-具体实现">4.3.2.2 具体实现</h5>
<ol>
<li>将G的边按权重升序排序，定义一个并查集，初始化为n个顶点的值为其下标</li>
<li>选择最小权值的边并从边集合中去除，若边上两个结点在并查集中不属于一个集合，则将边加入到结果集中，并将边上两个结点合并到一个集合</li>
<li>循环2)直到边全部遍历完成s或者边的数量等于|V|-1</li>
</ol>
<h3 id="44-最短路径算法">4.4 最短路径算法</h3>
<h4 id="441-dijkstra算法求单源最短路径">4.4.1 Dijkstra算法求单源最短路径</h4>
<h5 id="4411-算法思想">4.4.1.1 算法思想</h5>
<ol>
<li>引入辅助数组：s标记已计算完成的顶点，全部初始化为0，源点为1；dist记录从源点到其他各顶点当前最短路径长度，初始化为源点到各顶点的边的权值或INF；path记录最短路径中到达各顶点所经过的最后一个顶点，全部初始化为源点下标</li>
<li>根据条件s[i] == 0 &amp;&amp; dist[i] = min(dist&hellip;)选择下标i，将s[i]设为1并遍历顶点vi的边(vi, vj)并以 if (dist[i] + weight(vi, vj) &lt; dist[j]) { dist[j] = dist[i] + weight(vi, vj) &lt; dist[j]; path[j] = i } 的逻辑更新dist数组和path数组，意思即为如果从源点经过已知最短路径的结点vi到达结点vj的路径长度要小于当前从源点到结点vj的路径长度，则更新当前从源点到vj的最小路径长度为经过vi到结点vj的路径长度dist[i] + weight(vi, vj)</li>
<li>循环2)直到求出从源点到所有顶点的最短路径</li>
</ol>
<ul>
<li>Dijkstra算法不支持带负权值路径的图求最短路径</li>
</ul>
<h5 id="4412-代码实现">4.4.1.2 代码实现</h5>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cm">/**
</span><span class="cm"> * Dijkstra算法求最短路径.
</span><span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">Dijkstra</span><span class="p">(</span><span class="n">AdjListGraph</span> <span class="o">*</span><span class="n">G</span><span class="p">,</span> <span class="kt">char</span> <span class="n">startVex</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">start_idx</span> <span class="o">=</span> <span class="n">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">startVex</span><span class="p">);</span>
    <span class="c1">// 数据初始化.
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">dist</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">path</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">s</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_VERTEX_NUM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
        <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">start_idx</span><span class="p">;</span>
        <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">solved</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">dist</span><span class="p">[</span><span class="n">start_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">s</span><span class="p">[</span><span class="n">start_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">start_idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">firstArc</span><span class="p">;</span> <span class="n">arc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">arc</span><span class="o">-&gt;</span><span class="n">nextArc</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dist</span><span class="p">[</span><span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">start_idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">arc</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dist</span><span class="p">[</span><span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">start_idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">arc</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">;</span>
            <span class="n">path</span><span class="p">[</span><span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">start_idx</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 开始循环.
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">solved</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 找s为0且dist最小值.
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">cur_min</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">cur_min_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">cur_min</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">cur_min</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">cur_min_idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">cur_min_idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 从startVex结点无法到达所有结点，直接结束
</span><span class="c1"></span>            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 将cur_min_idx加入已找到的集合并更新数组.
</span><span class="c1"></span>        <span class="n">s</span><span class="p">[</span><span class="n">cur_min_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">cur_min_idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">firstArc</span><span class="p">;</span> <span class="n">arc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">arc</span><span class="o">-&gt;</span><span class="n">nextArc</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dist</span><span class="p">[</span><span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">cur_min_idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">arc</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dist</span><span class="p">[</span><span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">cur_min_idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">arc</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">;</span>
                <span class="n">path</span><span class="p">[</span><span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_min_idx</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 开始输出结果.
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 输出从start到i的路径和其长度
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">stack</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">start_idx</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">stack</span><span class="p">[</span><span class="o">++</span><span class="n">top</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">t</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">stack</span><span class="p">[</span><span class="o">++</span><span class="n">top</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">start_idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">top</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">stack</span><span class="p">[</span><span class="n">top</span><span class="o">--</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;-&gt;&#34;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h4 id="442-floyd算法求各顶点之间最短路径">4.4.2 Floyd算法求各顶点之间最短路径</h4>
<h5 id="4421-算法思想">4.4.2.1 算法思想</h5>
<p>设立一个n阶方阵A, 其随着算法过程存在递推关系，初始为A^-1[i][j] = arc[i][j]，递推公式：A^m[i][j] = min{A^m-1[i][j], A^m-1[i][k] + A^m-1[k][j]}, k = 0, 1 &hellip; , n-1 (意思就是算法循环顶点v0到vn-1，每次循环都判断一下从顶点vi到顶点vj的路径如果是经过当前循环顶点会不会更近) <!-- raw HTML omitted -->
设立一个n阶方阵P，P[i][j]表示从顶点vi到顶点vj的当前最短路径除j以外的最后的一个顶点，初始化为P[i][j] = exist(&lt;vi, vj&gt;) 
? i : -1；在算法进行到k=m时A[i][j]被更新了，同步更新P[i][j] = m</p>
<p>以下图为例
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="%e5%b8%a6%e6%9d%83%e6%9c%89%e5%90%91%e5%9b%be.jpg"
        data-srcset="%e5%b8%a6%e6%9d%83%e6%9c%89%e5%90%91%e5%9b%be.jpg, %e5%b8%a6%e6%9d%83%e6%9c%89%e5%90%91%e5%9b%be.jpg 1.5x, %e5%b8%a6%e6%9d%83%e6%9c%89%e5%90%91%e5%9b%be.jpg 2x"
        data-sizes="auto"
        alt="带权有向图.jpg"
        title="带权有向图" /></p>
<ol>
<li>初始化得</li>
</ol>
<pre><code>A:
0 3 1 4 I
I 0 2 I I
I I 0 5 6
I I I 0 I
I I I I 0

P:
- 0 0 0 -
- - 1 - -
- - - 2 2
- - - - -
- - - - - 
</code></pre><ol start="2">
<li>判断从i到j经过v0结点是否会变短，因为A[i][0]全部为INF，所以不会变短，无更新</li>
<li>判断从i到j经过v1结点是否会变短，因为A[0][1] + A[1][2] = 5 &gt; 2 = A[0][2]，所以不会变短，无更新</li>
<li>判断从i到j经过v2结点是否会变短，因为A[0][2] + A[2][4] = 7 &lt; INF = A[0][4]，所以从v0到v4的路径长度变短，同样的从v1到V3和从v1到v4的路径长度也会变短，更新矩阵</li>
</ol>
<pre><code>A:
0 3 1 4 7
I 0 2 7 8
I I 0 5 6
I I I 0 I
I I I I 0

P:
- 0 0 0 2
- - 1 2 2
- - - 2 2
- - - - -
- - - - -
</code></pre><ol start="5">
<li>判断从i到j经过v3结点是否会变短，判断结果不会变短</li>
<li>判断从i到j经过v4结点是否会变短，判断结果不会变短，算法执行结束</li>
<li>分析矩阵，以v0到v4为例: <!-- raw HTML omitted -->
v0-&gt;&hellip;-&gt;v4路径长度为7，逆推路径为P[0][4] = 2, 即有v0-&gt;&hellip;-&gt;v2-&gt;v4, P[0][2] = 0, 即有完整路径v0-&gt;v2-&gt;v4</li>
</ol>
<h5 id="4422-代码实现">4.4.2.2 代码实现</h5>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cm">/**
</span><span class="cm"> * Floyd算法求各顶点之间的最短路径，接受参数为A的邻接矩阵
</span><span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">Floyd</span><span class="p">(</span><span class="n">AdjListGraph</span> <span class="o">*</span><span class="n">G</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 数据初始化.
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">A</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">][</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">P</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">][</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_VERTEX_NUM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">MAX_VERTEX_NUM</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
            <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">firstArc</span><span class="p">;</span> <span class="n">arc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">arc</span><span class="o">-&gt;</span><span class="n">nextArc</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">arc</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">;</span>
            <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 算法开始.
</span><span class="c1"></span>    <span class="c1">// k代表正在遍历的顶点下标，i代表最短路径起点，j代表最短路径终点
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 打印各顶点之间的最短路径和其长度.
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">INF</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">//                char start = G-&gt;vertex[i]-&gt;data;
</span><span class="c1">//                char end = G-&gt;vertex[j]-&gt;data;
</span><span class="c1">//                std::cout &lt;&lt; start &lt;&lt; &#34;-&gt;&#34; &lt;&lt; end &lt;&lt; &#34;-&gt;INF&#34; &lt;&lt; std::endl;
</span><span class="c1"></span>                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="kt">int</span> <span class="n">stack</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="n">stack</span><span class="p">[</span><span class="o">++</span><span class="n">top</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">cur</span><span class="p">];</span>
                <span class="n">stack</span><span class="p">[</span><span class="o">++</span><span class="n">top</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">top</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="n">top</span><span class="o">--</span><span class="p">]]</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;-&gt;&#34;</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 输出结果如下:
</span><span class="c1">// A-&gt;B-&gt;3
</span><span class="c1">// A-&gt;C-&gt;1
</span><span class="c1">// A-&gt;D-&gt;4
</span><span class="c1">// A-&gt;C-&gt;E-&gt;7
</span><span class="c1">// B-&gt;C-&gt;2
</span><span class="c1">// B-&gt;C-&gt;D-&gt;7
</span><span class="c1">// B-&gt;C-&gt;E-&gt;8
</span><span class="c1">// C-&gt;D-&gt;5
</span><span class="c1">// C-&gt;E-&gt;6
</span></code></pre></div><h3 id="44-拓扑排序">4.4 拓扑排序</h3>
<h4 id="441-有向无环图">4.4.1 有向无环图</h4>
<p>不存在环的图, 记作DAG</p>
<h4 id="442-aov网">4.4.2 AOV网</h4>
<p>若用一个DAG表示一个工程，其顶点表示活动，用有向边&lt;vi, vj&gt;表示活动vi先于活动vj进行的传递关系，则将这种DAG称为AOV网(Activity On Vertex)</p>
<h4 id="443-拓扑排序">4.4.3 拓扑排序</h4>
<p>对DAG所有顶点的一种排序，使若存在一条从顶点A到顶点B的路径，在排序中B排在A的后面</p>
<h4 id="444-算法思想">4.4.4 算法思想</h4>
<ol>
<li>从DAG中选择一个没有前驱的顶点</li>
<li>从DAG中删除该顶点和所有以它为起点的有向边</li>
<li>重复1),2)直到DAG为空(或存在从图中选择不到没有前驱的结点，且图非空的情况，说明图中有环，即图非DAG)</li>
</ol>
<h4 id="445-求有向图所有拓扑排序序列代码实现">4.4.5 求有向图所有拓扑排序序列代码实现</h4>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">TreeNode</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">child</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">childNums</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">bool</span> <span class="nf">TopologicalSortHelp</span><span class="p">(</span><span class="n">AdjListGraph</span> <span class="o">*</span><span class="n">G</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*&amp;</span><span class="n">root</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">inDegree</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cur_in_dgree_zero_idx</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cur_in_dgree_zero_idx</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">inDegree</span><span class="p">[</span><span class="n">cur_in_dgree_zero_idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">cur_in_dgree_zero_idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">firstArc</span><span class="p">;</span> <span class="n">arc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">arc</span><span class="o">-&gt;</span><span class="n">nextArc</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">inDegree</span><span class="p">[</span><span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">inDegree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">inDegree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">tnode</span> <span class="o">=</span> <span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TreeNode</span><span class="p">));</span>
            <span class="n">tnode</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">tnode</span><span class="o">-&gt;</span><span class="n">childNums</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">root</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">childNums</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">tnode</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TopologicalSortHelp</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tnode</span><span class="p">,</span> <span class="n">inDegree</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">_Traverse_TREE</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">t</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">childNums</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">childNums</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_Traverse_TREE</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**
</span><span class="cm"> * 打印DAG的所有拓扑排序序列.
</span><span class="cm"> */</span>
<span class="kt">bool</span> <span class="nf">TopologicalSort</span><span class="p">(</span><span class="n">AdjListGraph</span> <span class="o">*</span><span class="n">G</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 各顶点入度，-1表示顶点已经加入到拓扑排序序列中了
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">inDegree</span><span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">firstArc</span><span class="p">;</span> <span class="n">arc</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">arc</span><span class="o">-&gt;</span><span class="n">nextArc</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">inDegree</span><span class="p">[</span><span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">auto</span> <span class="n">root</span> <span class="o">=</span> <span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TreeNode</span><span class="p">));</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">childNums</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TopologicalSortHelp</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inDegree</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 遍历生成的结果树，得到结果序列
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">t</span><span class="p">;</span>
    <span class="n">_Traverse_TREE</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;-&gt;&#34;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="45-关键路径">4.5 关键路径</h3>
<h4 id="451-aoe网">4.5.1 AOE网</h4>
<p>在有向带权图中，以顶点表示事件，以有向边表示活动，以边上权值表示完成该活动的开销(如：完成活动所需时间)，则称该有向图为AOE(Activity On Edge)网。</p>
<ul>
<li>源点: AOE网中入度为0的点</li>
<li>汇点：AOE网中出度为0的点</li>
</ul>
<h4 id="452-关键路径">4.5.2 关键路径</h4>
<p>从源点到汇点最大路径长度的路径称为关键路径，关键路径上的活动被称为关键活动</p>
<h4 id="453-关键路径计算过程">4.5.3 关键路径计算过程</h4>
<ol>
<li>计算事件(顶点)的最早发生时间Ve，需注意事件发生的前提是其前置事件全部完成，故可以按拓扑排序序列来计算事件的最早发生事件，设事件vi有前置事件vh1、vh2, 有活动&lt;vh1, vi&gt;、&lt;vh2, vi&gt;，则vi的最早发生时间Vei为max(Veh1 + weight(&lt;vh1, vi&gt;), Veh2 + weight(&lt;vh2, vi&gt;))</li>
<li>计算事件的最迟发生时间Vl，设置汇点的最迟发生时间等于其最早发生时间，按逆拓扑排序序列来计算时间的最迟发生时间，设事件vi有后继事件vh1、vh2, 有活动&lt;vi, vh1&gt;、&lt;vi, vh2&gt;，则vi的最迟发生时间Vli为min(Vlh1 - weight(&lt;vi, vh1&gt;), Vlh2 - weight(&lt;vi, vh2&gt;))</li>
<li>计算活动的最早发生时间e，若存在&lt;vk, vj&gt;表示活动i，则ei = Vek</li>
<li>计算活动的最迟发生时间l，若存在&lt;vk, vj&gt;表示活动i，则li = Vlj - weight(&lt;vk, vj&gt;)</li>
<li>最早发生时间和最迟发生时间相同的事件即为关键路径上的事件，最早发生时间和最迟发生时间相同的活动即为关键路径上的活动</li>
</ol>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2021-03-15</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/redis/redis_java%E5%AE%A2%E6%88%B7%E7%AB%AF-jedis/" class="prev" rel="prev" title="Java客户端 Jedis与lettuce"><i class="fas fa-angle-left fa-fw"></i>Java客户端 Jedis与lettuce</a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.81.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/posts/" target="_blank">Riddle</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
