<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>图 - Riddle&#39;s Notebook</title><meta name="Description" content=""><meta property="og:title" content="图" />
<meta property="og:description" content="图 1. 定义 图G由顶点集V和边集E组成，记作G = (V, E)其中V(G)表示图G中顶点的有限非空集, E(G)表示图G中顶点之间的关系(边)集合|V|表" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://maoqiankun97.github.io/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-15T20:30:02&#43;08:00" />
<meta property="article:modified_time" content="2021-03-15T20:30:02&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="图"/>
<meta name="twitter:description" content="图 1. 定义 图G由顶点集V和边集E组成，记作G = (V, E)其中V(G)表示图G中顶点的有限非空集, E(G)表示图G中顶点之间的关系(边)集合|V|表"/>
<meta name="application-name" content="Riddle&#39;s Notebook">
<meta name="apple-mobile-web-app-title" content="Riddle&#39;s Notebook"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://maoqiankun97.github.io/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/" /><link rel="prev" href="https://maoqiankun97.github.io/posts/redis/redis_java%E5%AE%A2%E6%88%B7%E7%AB%AF-jedis/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "图",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/maoqiankun97.github.io\/posts\/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\/%E5%9B%BE\/"
        },"genre": "posts","keywords": "数据结构","wordcount":  4207 ,
        "url": "https:\/\/maoqiankun97.github.io\/posts\/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\/%E5%9B%BE\/","datePublished": "2021-03-15T20:30:02+08:00","dateModified": "2021-03-15T20:30:02+08:00","publisher": {
            "@type": "Organization",
            "name": "Riddle"},"author": {
                "@type": "Person",
                "name": "Riddle"
            },"description": ""
    }
    </script></head>
    <body header-desktop="" header-mobile=""><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : '' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Riddle&#39;s Notebook">Riddle&#39;s Notebook</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Riddle&#39;s Notebook">Riddle&#39;s Notebook</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">图</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/posts/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>Riddle</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><i class="far fa-folder fa-fw"></i>数据结构</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-03-15">2021-03-15</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 4207 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 9 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#1-定义">1. 定义</a>
      <ul>
        <li><a href="#11-简单图">1.1 简单图</a></li>
        <li><a href="#12-多重图">1.2 多重图</a></li>
        <li><a href="#13-完全图">1.3 完全图</a></li>
        <li><a href="#14-子图与生成子图">1.4 子图与生成子图</a></li>
        <li><a href="#15-连通与强连通">1.5 连通与强连通</a></li>
        <li><a href="#16-连通图与强连通图">1.6 连通图与强连通图</a></li>
        <li><a href="#17-连通分量与强连通分量">1.7 连通分量与强连通分量</a></li>
        <li><a href="#18-生成树与生成森林">1.8 生成树与生成森林</a></li>
        <li><a href="#19-顶点的度">1.9 顶点的度</a></li>
        <li><a href="#110-网">1.10 网</a></li>
        <li><a href="#111-稠密图与稀疏图">1.11 稠密图与稀疏图</a></li>
        <li><a href="#112-有向树">1.12 有向树</a></li>
        <li><a href="#113-路径">1.13 路径</a></li>
        <li><a href="#114-路径长度">1.14 路径长度</a></li>
        <li><a href="#115-回路">1.15 回路</a></li>
      </ul>
    </li>
    <li><a href="#2-基本操作">2. 基本操作</a>
      <ul>
        <li><a href="#21-adjacentg-x-y">2.1 Adjacent(G, x, y)</a></li>
        <li><a href="#22-neighborsg-x">2.2 Neighbors(G, x)</a></li>
        <li><a href="#23-insertvertexg-x">2.3 InsertVertex(G, x)</a></li>
        <li><a href="#24-deletevertexg-x">2.4 DeleteVertex(G, x)</a></li>
        <li><a href="#25-addedgeg-x-y">2.5 AddEdge(G, x, y)</a></li>
        <li><a href="#26-removeedgeg-x-y">2.6 RemoveEdge(G, x, y)</a></li>
        <li><a href="#27-firstneighborg-x">2.7 FirstNeighbor(G, x)</a></li>
        <li><a href="#28-nextneighborsg-x-y">2.8 NextNeighbors(G， x, y)</a></li>
      </ul>
    </li>
    <li><a href="#3-存储结构">3. 存储结构</a>
      <ul>
        <li><a href="#31-邻接矩阵法">3.1 邻接矩阵法</a></li>
        <li><a href="#32-邻接表法">3.2 邻接表法</a></li>
        <li><a href="#33-十字链表法">3.3 十字链表法</a></li>
        <li><a href="#34-邻接多重表法">3.4 邻接多重表法</a></li>
      </ul>
    </li>
    <li><a href="#4-常用算法">4. 常用算法</a>
      <ul>
        <li><a href="#41-广度优先搜索">4.1 广度优先搜索</a></li>
        <li><a href="#42-深度优先搜索">4.2 深度优先搜索</a></li>
        <li><a href="#43-最小生成树算法">4.3 最小生成树算法</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="图">图</h1>
<h2 id="1-定义">1. 定义</h2>
<p>图G由顶点集V和边集E组成，记作G = (V, E)<!-- raw HTML omitted -->
其中V(G)表示图G中顶点的有限非空集, E(G)表示图G中顶点之间的关系(边)集合<!-- raw HTML omitted -->
|V|表示图中顶点个数，也称为图G的阶<!-- raw HTML omitted -->
|E|表示图中边的条数
<!-- raw HTML omitted -->
例：<!-- raw HTML omitted -->
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./%e5%9b%be%e9%99%84%e4%bb%b6/%e5%9b%be1.1.png"
        data-srcset="./%e5%9b%be%e9%99%84%e4%bb%b6/%e5%9b%be1.1.png, ./%e5%9b%be%e9%99%84%e4%bb%b6/%e5%9b%be1.1.png 1.5x, ./%e5%9b%be%e9%99%84%e4%bb%b6/%e5%9b%be1.1.png 2x"
        data-sizes="auto"
        alt="./图附件/图1.1.png"
        title="图1.1" />
<!-- raw HTML omitted -->
V(G) = {A, B, C, D, E}<!-- raw HTML omitted -->
E(G) = {(A, B), (A, C), (A, D), (B, C), (C, E), (C, D)} <!-- raw HTML omitted -->
|V| = 5 <!-- raw HTML omitted -->
|E| = 6</p>
<h3 id="11-简单图">1.1 简单图</h3>
<p>无重复边且不存在结点到自身的边的图</p>
<h3 id="12-多重图">1.2 多重图</h3>
<p>非简单图</p>
<h3 id="13-完全图">1.3 完全图</h3>
<h4 id="131-无向完全图">1.3.1 无向完全图</h4>
<p>任意两个顶点之间都存在边</p>
<h4 id="132-有向完全图">1.3.2 有向完全图</h4>
<p>任意两个顶点之间都存在方向相反的弧</p>
<h3 id="14-子图与生成子图">1.4 子图与生成子图</h3>
<h4 id="141-子图">1.4.1 子图</h4>
<p>子图定义: G'=(V', E'), G=(V, E), 其中V&rsquo;是V的子集, E&rsquo;是E的子集, 则称G&rsquo;是G的子图<!-- raw HTML omitted --></p>
<h4 id="142-生成子图">1.4.2 生成子图</h4>
<p>生成子图: 当G'=(V', E')是G=(V, E)的子图, 且V'=V, 则称G&rsquo;是G的生成子图</p>
<h3 id="15-连通与强连通">1.5 连通与强连通</h3>
<h4 id="151-连通">1.5.1 连通</h4>
<p>连通是一个针对无向图的概念，从顶点V到顶点W之间有路径存在，则称V和W是连通的。如：V &mdash; O &mdash; W</p>
<h4 id="152-强连通">1.5.2 强连通</h4>
<p>强连通是一个针对有向图的概念，从顶点V到顶点W和从顶点W到顶点V之间都有路径，则称V和W是强连通的。如：<!-- raw HTML omitted --></p>
<pre><code>V ---&gt; O ---&gt; W
^             |
|             |
L ------------|
</code></pre><h3 id="16-连通图与强连通图">1.6 连通图与强连通图</h3>
<h4 id="161-连通图">1.6.1 连通图</h4>
<p>对于无向图，任意两个顶点之间都是连通的，则称该无向图为连通图</p>
<ul>
<li>n个顶点的强连通图至少有n-1条边</li>
</ul>
<h4 id="162-强连通图">1.6.2 强连通图</h4>
<p>对于有向图，任意两个顶点之间都是强连通的，则称该有向图为强连通图</p>
<ul>
<li>n个顶点的强连通图至少有n条边</li>
</ul>
<h3 id="17-连通分量与强连通分量">1.7 连通分量与强连通分量</h3>
<p>对于G的一个(强)连通子图G'，若不存在G的另一个(强)连通子图G''，使得G' ⊂ G''，则称G&rsquo;是G的(强)连通分量</p>
<h3 id="18-生成树与生成森林">1.8 生成树与生成森林</h3>
<h4 id="181-极小连通子图">1.8.1 极小连通子图</h4>
<p>极小连通子图即包含边最少的连通子图</p>
<h4 id="182-生成树">1.8.2 生成树</h4>
<p>G是一个连通图，其包含G所有顶点的极小连通子图称作生成树</p>
<h4 id="183-生成森林">1.8.3 生成森林</h4>
<p>G是一个非连通图，其所有连通分量的生成树组成了其生成森林</p>
<h3 id="19-顶点的度">1.9 顶点的度</h3>
<h4 id="191-无向图">1.9.1 无向图</h4>
<p>以V为端点的边的数量，记作TD(V)</p>
<h4 id="192-有向图">1.9.2 有向图</h4>
<p>以V为起点的有向边的数量，记作OD(V)<!-- raw HTML omitted -->
以V为终点的有向边的数量，记作ID(V)<!-- raw HTML omitted -->
TD(V) = OD(V) + ID(V)</p>
<h3 id="110-网">1.10 网</h3>
<p>边有权重的图称作网</p>
<h3 id="111-稠密图与稀疏图">1.11 稠密图与稀疏图</h3>
<p>边多的图称为稠密图，反之边少的图称为稀疏图。具体的界限没有定义</p>
<h3 id="112-有向树">1.12 有向树</h3>
<p>一个顶点入度为0，其余顶点入度为1的有向图</p>
<h3 id="113-路径">1.13 路径</h3>
<p>从顶点V到顶点W的顶点序列<!-- raw HTML omitted -->
序列中顶点不重复的路径被称为简单路径</p>
<h3 id="114-路径长度">1.14 路径长度</h3>
<p>路径上边的长度</p>
<h3 id="115-回路">1.15 回路</h3>
<p>第一个顶点与最后一个顶点相同的路径</p>
<h2 id="2-基本操作">2. 基本操作</h2>
<h3 id="21-adjacentg-x-y">2.1 Adjacent(G, x, y)</h3>
<p>判断G中是否存在&lt;x, y&gt;或(x, y)</p>
<h3 id="22-neighborsg-x">2.2 Neighbors(G, x)</h3>
<p>列出G中与x邻接的顶点集合</p>
<h3 id="23-insertvertexg-x">2.3 InsertVertex(G, x)</h3>
<p>在图G中插入顶点x</p>
<h3 id="24-deletevertexg-x">2.4 DeleteVertex(G, x)</h3>
<p>在图G中删除顶点x</p>
<h3 id="25-addedgeg-x-y">2.5 AddEdge(G, x, y)</h3>
<p>若(x, y)或&lt;x, y&gt;不存在，添加</p>
<h3 id="26-removeedgeg-x-y">2.6 RemoveEdge(G, x, y)</h3>
<p>若(x, y)或&lt;x, y&gt;存在，删除</p>
<h3 id="27-firstneighborg-x">2.7 FirstNeighbor(G, x)</h3>
<p>求图G中与x邻接的第一个顶点</p>
<h3 id="28-nextneighborsg-x-y">2.8 NextNeighbors(G， x, y)</h3>
<p>求图G中x除y之外的下一个邻接顶点</p>
<h2 id="3-存储结构">3. 存储结构</h2>
<h3 id="31-邻接矩阵法">3.1 邻接矩阵法</h3>
<h4 id="311-定义">3.1.1 定义</h4>
<p>|V| = n的图，邻接矩阵A为n*n<!-- raw HTML omitted -->
设V的编号为v1、v2、&hellip;、vn
若&lt;vi, vj&gt; ∈ E, 则A[i][j] = 1，否则A[i][j] = 0或正无穷 (对于网，A[i][j]表示权重);</p>
<ul>
<li>对于图G的邻接矩阵A， A^n的含义：A^n[i][j]表示从顶点vi到顶点vj长度为n的路径条数</li>
</ul>
<p>例:<!-- raw HTML omitted -->
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./%e5%9b%be%e9%99%84%e4%bb%b6/%e5%9b%be1.1.png"
        data-srcset="./%e5%9b%be%e9%99%84%e4%bb%b6/%e5%9b%be1.1.png, ./%e5%9b%be%e9%99%84%e4%bb%b6/%e5%9b%be1.1.png 1.5x, ./%e5%9b%be%e9%99%84%e4%bb%b6/%e5%9b%be1.1.png 2x"
        data-sizes="auto"
        alt="./图附件/图1.1.png"
        title="图1.1" /></p>
<p>将A编号为0~E编号为4
其邻接矩阵为</p>
<pre><code>0 1 1 1 - 
1 0 1 - - 
1 1 0 1 1 
1 - 1 0 - 
- - 1 - 0
</code></pre><h4 id="312-存储结构代码实现">3.1.2 存储结构代码实现</h4>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="nc">MatrixGraph</span> <span class="p">{</span>
    <span class="c1">// 顶点集合, 下标代表顶点的序号, 对应下标的值代表顶点的值, 为了简单, 限定顶点值只能为A~Z
</span><span class="c1"></span>    <span class="kt">char</span> <span class="n">V</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span>
    <span class="c1">// 顶点位置, 即顶点在邻接矩阵中的下标
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">vertexLocation</span><span class="p">[</span><span class="mi">26</span><span class="p">];</span>
    <span class="c1">// 顶点数量
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">vertexNum</span><span class="p">;</span>
    <span class="c1">// 邻接矩阵
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">A</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">][</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span>
    <span class="c1">// 边的数量
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">edgeNum</span><span class="p">;</span>
    <span class="c1">// 是否为有向图
</span><span class="c1"></span>    <span class="kt">bool</span> <span class="n">directed</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div><h4 id="313-基本操作实现">3.1.3 基本操作实现</h4>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">bool</span> <span class="nf">CreateGraph</span><span class="p">(</span><span class="n">MatrixGraph</span> <span class="o">*&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v_num</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">v</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">e_num</span><span class="p">,</span> <span class="kt">char</span> <span class="n">e</span><span class="p">[][</span><span class="mi">2</span><span class="p">],</span> <span class="kt">bool</span> <span class="n">directed</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v_num</span> <span class="o">&gt;</span> <span class="n">MAX_VERTEX_NUM</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">G</span> <span class="o">=</span> <span class="p">(</span><span class="n">MatrixGraph</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">MatrixGraph</span><span class="p">));</span>
    <span class="n">G</span><span class="o">-&gt;</span><span class="n">directed</span> <span class="o">=</span> <span class="n">directed</span><span class="p">;</span>
    <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span> <span class="o">=</span> <span class="n">v_num</span><span class="p">;</span>
    <span class="n">G</span><span class="o">-&gt;</span><span class="n">edgeNum</span> <span class="o">=</span> <span class="n">e_num</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexLocation</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexLocation</span><span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">v_num</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">e_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">InsertEdge</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">DestroyGraph</span><span class="p">(</span><span class="n">MatrixGraph</span> <span class="o">*&amp;</span><span class="n">G</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">LocateVex</span><span class="p">(</span><span class="n">MatrixGraph</span> <span class="o">*</span><span class="n">G</span><span class="p">,</span> <span class="kt">char</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">return</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexLocation</span><span class="p">[</span><span class="n">v</span> <span class="o">-</span> <span class="sc">&#39;A&#39;</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">FirstAdjVex</span><span class="p">(</span><span class="n">MatrixGraph</span> <span class="o">*</span><span class="n">G</span><span class="p">,</span> <span class="kt">char</span> <span class="n">v</span><span class="p">,</span> <span class="kt">char</span> <span class="o">&amp;</span><span class="n">adjVex</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">v_index</span> <span class="o">=</span> <span class="n">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">v_index</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">v_index</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">adjVex</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">NextAdjVex</span><span class="p">(</span><span class="n">MatrixGraph</span> <span class="o">*</span><span class="n">G</span><span class="p">,</span> <span class="kt">char</span> <span class="n">v</span><span class="p">,</span> <span class="kt">char</span> <span class="n">w</span><span class="p">,</span> <span class="kt">char</span> <span class="o">&amp;</span><span class="n">nextAdjVex</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">v_index</span> <span class="o">=</span> <span class="n">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">w_index</span> <span class="o">=</span> <span class="n">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">w_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">v_index</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">v_index</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">nextAdjVex</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">InsertVex</span><span class="p">(</span><span class="n">MatrixGraph</span> <span class="o">*&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">char</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span> <span class="o">&gt;=</span> <span class="n">MAX_VERTEX_NUM</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexLocation</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">G</span><span class="o">-&gt;</span><span class="n">V</span><span class="p">[</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexLocation</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="p">;</span>
    <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="o">++</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">DeleteVex</span><span class="p">(</span><span class="n">MatrixGraph</span> <span class="o">*&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">char</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">v_index</span> <span class="o">=</span> <span class="n">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexLocation</span><span class="p">[</span><span class="n">v</span> <span class="o">-</span> <span class="sc">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">flag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_VERTEX_NUM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">MAX_VERTEX_NUM</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">G</span><span class="o">-&gt;</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">V</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="o">--</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_VERTEX_NUM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">directed</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">v_index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">v_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
                <span class="n">G</span><span class="o">-&gt;</span><span class="n">edgeNum</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">v_index</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">v_index</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
                <span class="n">G</span><span class="o">-&gt;</span><span class="n">edgeNum</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">v_index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">v_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
                <span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">v_index</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
                <span class="n">G</span><span class="o">-&gt;</span><span class="n">edgeNum</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">InsertEdge</span><span class="p">(</span><span class="n">MatrixGraph</span> <span class="o">*&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">char</span> <span class="n">v</span><span class="p">,</span> <span class="kt">char</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">v_index</span> <span class="o">=</span> <span class="n">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">w_index</span> <span class="o">=</span> <span class="n">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">w_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">directed</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">v_index</span><span class="p">][</span><span class="n">w_index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">v_index</span><span class="p">][</span><span class="n">w_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">edgeNum</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">v_index</span><span class="p">][</span><span class="n">w_index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">v_index</span><span class="p">][</span><span class="n">w_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">w_index</span><span class="p">][</span><span class="n">v_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">edgeNum</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">DeleteEdge</span><span class="p">(</span><span class="n">MatrixGraph</span> <span class="o">*&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">char</span> <span class="n">v</span><span class="p">,</span> <span class="kt">char</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">v_index</span> <span class="o">=</span> <span class="n">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">w_index</span> <span class="o">=</span> <span class="n">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">w_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">directed</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">v_index</span><span class="p">][</span><span class="n">w_index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">v_index</span><span class="p">][</span><span class="n">w_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">edgeNum</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">v_index</span><span class="p">][</span><span class="n">w_index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">v_index</span><span class="p">][</span><span class="n">w_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">w_index</span><span class="p">][</span><span class="n">v_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">edgeNum</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="32-邻接表法">3.2 邻接表法</h3>
<h4 id="321-定义">3.2.1 定义</h4>
<p>邻接表(Adjacency List)是图的一种链式存储结构。对图中每个顶点，设立一个表头结点，在表头结点中有两个域:顶点信息域(data)和指向其关联的边的域(firstarc)指向其边表链表结点。vi的边表链表中的一个结点表示依附于顶点vi的边(对于有向图则是以vi为尾的弧)，每个链表结点由2个域组成，其中邻接点域(adjvex)表示与顶点vi邻接的点在图中的位置，链域(nextarc)指示下一条边或弧的链表结点。如果边有权重等信息，可额外添加域来存储信息。</p>
<p>例:<!-- raw HTML omitted -->
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./%e5%9b%be%e9%99%84%e4%bb%b6/%e5%9b%be1.1.png"
        data-srcset="./%e5%9b%be%e9%99%84%e4%bb%b6/%e5%9b%be1.1.png, ./%e5%9b%be%e9%99%84%e4%bb%b6/%e5%9b%be1.1.png 1.5x, ./%e5%9b%be%e9%99%84%e4%bb%b6/%e5%9b%be1.1.png 2x"
        data-sizes="auto"
        alt="./图附件/图1.1.png"
        title="图1.1" /></p>
<p>将A编号为0~E编号为4
其邻接表为
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./%e5%9b%be%e9%99%84%e4%bb%b6/%e9%82%bb%e6%8e%a5%e8%a1%a8%e5%ad%98%e5%82%a8.png"
        data-srcset="./%e5%9b%be%e9%99%84%e4%bb%b6/%e9%82%bb%e6%8e%a5%e8%a1%a8%e5%ad%98%e5%82%a8.png, ./%e5%9b%be%e9%99%84%e4%bb%b6/%e9%82%bb%e6%8e%a5%e8%a1%a8%e5%ad%98%e5%82%a8.png 1.5x, ./%e5%9b%be%e9%99%84%e4%bb%b6/%e9%82%bb%e6%8e%a5%e8%a1%a8%e5%ad%98%e5%82%a8.png 2x"
        data-sizes="auto"
        alt="./图附件/邻接表存储.png"
        title="邻接表存储" /></p>
<h4 id="322-存储结构代码实现">3.2.2 存储结构代码实现</h4>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// 边表结点
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">ArcNode</span> <span class="p">{</span>
    <span class="c1">// 边表另一个顶点在图中的下标
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">adjVexIndex</span><span class="p">;</span>

    <span class="k">struct</span> <span class="nc">ArcNode</span> <span class="o">*</span><span class="n">nextArc</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 顶点结点
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">VNode</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">data</span><span class="p">;</span>

    <span class="k">struct</span> <span class="nc">ArcNode</span> <span class="o">*</span><span class="n">firstArc</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="nc">AdjListGraph</span> <span class="p">{</span>
    <span class="n">VNode</span> <span class="o">*</span><span class="n">vertex</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span>
    <span class="c1">// 顶点位置, 即顶点在邻接矩阵中的下标
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">vertexLocation</span><span class="p">[</span><span class="mi">26</span><span class="p">];</span>
    <span class="c1">// 顶点数量
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">vertexNum</span><span class="p">;</span>
    <span class="c1">// 边的数量
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">edgeNum</span><span class="p">;</span>
    <span class="c1">// 是否为有向图
</span><span class="c1"></span>    <span class="kt">bool</span> <span class="n">directed</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div><h4 id="323-基本操作实现">3.2.3 基本操作实现</h4>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">bool</span> <span class="nf">CreateGraph</span><span class="p">(</span><span class="n">AdjListGraph</span> <span class="o">*&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v_num</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">v</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">e_num</span><span class="p">,</span> <span class="kt">char</span> <span class="n">e</span><span class="p">[][</span><span class="mi">2</span><span class="p">],</span> <span class="kt">bool</span> <span class="n">directed</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v_num</span> <span class="o">&gt;</span> <span class="n">MAX_VERTEX_NUM</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">G</span> <span class="o">=</span> <span class="p">(</span><span class="n">AdjListGraph</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">AdjListGraph</span><span class="p">));</span>
    <span class="n">G</span><span class="o">-&gt;</span><span class="n">directed</span> <span class="o">=</span> <span class="n">directed</span><span class="p">;</span>
    <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span> <span class="o">=</span> <span class="n">v_num</span><span class="p">;</span>
    <span class="n">G</span><span class="o">-&gt;</span><span class="n">edgeNum</span> <span class="o">=</span> <span class="n">e_num</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexLocation</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">VNode</span> <span class="o">*</span><span class="n">vnode</span> <span class="o">=</span> <span class="p">(</span><span class="n">VNode</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">VNode</span><span class="p">));</span>
        <span class="n">vnode</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">vnode</span><span class="o">-&gt;</span><span class="n">firstArc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vnode</span><span class="p">;</span>
        <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexLocation</span><span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">e_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">InsertEdge</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">LocateVex</span><span class="p">(</span><span class="n">AdjListGraph</span> <span class="o">*</span><span class="n">G</span><span class="p">,</span> <span class="kt">char</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">return</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexLocation</span><span class="p">[</span><span class="n">v</span> <span class="o">-</span> <span class="sc">&#39;A&#39;</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">InsertEdge</span><span class="p">(</span><span class="n">AdjListGraph</span> <span class="o">*&amp;</span><span class="n">G</span><span class="p">,</span> <span class="kt">char</span> <span class="n">v</span><span class="p">,</span> <span class="kt">char</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">v_index</span> <span class="o">=</span> <span class="n">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">w_index</span> <span class="o">=</span> <span class="n">LocateVex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">w_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">directed</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ArcNode</span><span class="o">*</span> <span class="n">tailArch</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">ArcNode</span><span class="o">*</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">v_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">firstArc</span><span class="p">;</span> <span class="n">arc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">arc</span><span class="o">-&gt;</span><span class="n">nextArc</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span> <span class="o">==</span> <span class="n">w_index</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">tailArch</span> <span class="o">=</span> <span class="n">arc</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ArcNode</span> <span class="o">*</span><span class="n">arcNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">ArcNode</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ArcNode</span><span class="p">));</span>
        <span class="n">arcNode</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
        <span class="n">arcNode</span><span class="o">-&gt;</span><span class="n">nextArc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">tailArch</span><span class="o">-&gt;</span><span class="n">nextArc</span> <span class="o">=</span> <span class="n">arcNode</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 插入v-w
</span><span class="c1"></span>        <span class="n">ArcNode</span><span class="o">*</span> <span class="n">tailArch</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">ArcNode</span><span class="o">*</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">v_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">firstArc</span><span class="p">;</span> <span class="n">arc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">arc</span><span class="o">-&gt;</span><span class="n">nextArc</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span> <span class="o">==</span> <span class="n">w_index</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">tailArch</span> <span class="o">=</span> <span class="n">arc</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ArcNode</span> <span class="o">*</span><span class="n">arcNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">ArcNode</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ArcNode</span><span class="p">));</span>
        <span class="n">arcNode</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span> <span class="o">=</span> <span class="n">w_index</span><span class="p">;</span>
        <span class="n">arcNode</span><span class="o">-&gt;</span><span class="n">nextArc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tailArch</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">v_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">firstArc</span> <span class="o">=</span> <span class="n">arcNode</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">tailArch</span><span class="o">-&gt;</span><span class="n">nextArc</span> <span class="o">=</span> <span class="n">arcNode</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 插入w-v
</span><span class="c1"></span>        <span class="n">tailArch</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">ArcNode</span><span class="o">*</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">w_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">firstArc</span><span class="p">;</span> <span class="n">arc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">arc</span><span class="o">-&gt;</span><span class="n">nextArc</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span> <span class="o">==</span> <span class="n">v_index</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">tailArch</span> <span class="o">=</span> <span class="n">arc</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">arcNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">ArcNode</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ArcNode</span><span class="p">));</span>
        <span class="n">arcNode</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span> <span class="o">=</span> <span class="n">v_index</span><span class="p">;</span>
        <span class="n">arcNode</span><span class="o">-&gt;</span><span class="n">nextArc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tailArch</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">w_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">firstArc</span> <span class="o">=</span> <span class="n">arcNode</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">tailArch</span><span class="o">-&gt;</span><span class="n">nextArc</span> <span class="o">=</span> <span class="n">arcNode</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">G</span><span class="o">-&gt;</span><span class="n">edgeNum</span><span class="o">++</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="33-十字链表法">3.3 十字链表法</h3>
<h3 id="34-邻接多重表法">3.4 邻接多重表法</h3>
<h2 id="4-常用算法">4. 常用算法</h2>
<h3 id="41-广度优先搜索">4.1 广度优先搜索</h3>
<ul>
<li>树的层次遍历即为广度优先搜索</li>
<li>广度优先生成树
从图的顶点v出发进行广度优先搜索的步骤为：</li>
</ul>
<ol>
<li>首先访问起始顶点v</li>
<li>由v出发，依次访问v的各个未被访问的邻接顶点w1、w2 &hellip; wi</li>
<li>依次访问w1、w2 &hellip; wi的所有未被访问过的邻接顶点</li>
<li>以此类推</li>
</ol>
<p>代码实现:</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * 广度优先搜索.
</span><span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">BFS</span><span class="p">(</span><span class="n">AdjListGraph</span> <span class="o">*</span><span class="n">G</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">visit</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">false</span><span class="p">};</span>
    <span class="c1">// 定义一个队列备用
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">queue</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">front</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">rear</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">visit</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 从i开始遍历
</span><span class="c1"></span>        <span class="c1">// 入队并将i设为将要访问
</span><span class="c1"></span>        <span class="n">visit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">queue</span><span class="p">[</span><span class="n">rear</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">rear</span> <span class="o">=</span> <span class="p">(</span><span class="n">rear</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">front</span> <span class="o">!=</span> <span class="n">rear</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 出队访问
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">queue_front</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="n">front</span><span class="p">];</span>
            <span class="n">front</span> <span class="o">=</span> <span class="p">(</span><span class="n">front</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">queue_front</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; - &#34;</span><span class="p">;</span>
            <span class="c1">// 其未被访问的邻接结点入队
</span><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">queue_front</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">firstArc</span><span class="p">;</span> <span class="n">arc</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">arc</span><span class="o">-&gt;</span><span class="n">nextArc</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">visit</span><span class="p">[</span><span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span><span class="p">])</span> <span class="p">{</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">rear</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="n">front</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// 队列已满
</span><span class="c1"></span>                    <span class="k">return</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">visit</span><span class="p">[</span><span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">queue</span><span class="p">[</span><span class="n">rear</span><span class="p">]</span> <span class="o">=</span> <span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span><span class="p">;</span>
                <span class="n">rear</span> <span class="o">=</span> <span class="p">(</span><span class="n">rear</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div><h3 id="42-深度优先搜索">4.2 深度优先搜索</h3>
<ul>
<li>树的先序遍历可以理解为深度优先搜索</li>
<li>深度优先生成树
从图的顶点v出发进行广度优先搜索的步骤为：</li>
</ul>
<ol>
<li>首先访问v</li>
<li>由v出发访问v的任意一个邻接且未被访问过的邻接顶点wi</li>
<li>在访问域wi邻接且未被访问过的顶点yi</li>
<li>若wi无邻接且未被访问的顶点，则退回到v</li>
<li>重复以上过程至所有顶点均被访问过</li>
</ol>
<p>代码实现:</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * 从指定的顶点开始深度优先搜索.
</span><span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">DFS_i</span><span class="p">(</span><span class="n">AdjListGraph</span> <span class="o">*</span><span class="n">G</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vertex_index</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">visit</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">// 开始由i开始遍历
</span><span class="c1"></span>    <span class="n">visit</span><span class="p">[</span><span class="n">vertex_index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">vertex_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; - &#34;</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">vertex_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">firstArc</span><span class="p">;</span> <span class="n">arc</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="n">arc</span> <span class="o">=</span> <span class="n">arc</span><span class="o">-&gt;</span><span class="n">nextArc</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">visit</span><span class="p">[</span><span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">DFS_i</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">arc</span><span class="o">-&gt;</span><span class="n">adjVexIndex</span><span class="p">,</span> <span class="n">visit</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**
</span><span class="cm"> * 深度优先搜索.
</span><span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">DFS</span><span class="p">(</span><span class="n">AdjListGraph</span> <span class="o">*</span><span class="n">G</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">visit</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">false</span><span class="p">};</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">vertexNum</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">visit</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">DFS_i</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">visit</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="43-最小生成树算法">4.3 最小生成树算法</h3>
<p>对于带权无向连通图G=(V, E), G的所有生成树中边的权值之和最小的生成树为G的最小生成树(MST)，最小生成树有如下性质：</p>
<ul>
<li>最小生成树不一定唯一，对于每条边权重都不相同的情况一定是唯一的，对于G只有|V|-1条边是，MST也一定是唯一的</li>
<li>最小生成树的权值是唯一且相等的</li>
<li>最小生成树的边数为顶点数-1
大致算法思想:</li>
</ul>
<pre><code>GEN_MST(G)
    T = NULL;
    while T未形成一棵生成树
        找到一条最小代价边，且加入T后不会产生回路，设其为(u, v)
        T = T ∪ (u, v);
</code></pre><h4 id="431-prim算法">4.3.1 Prim算法</h4>
<h5 id="4311-流程描述">4.3.1.1 流程描述</h5>
<ol>
<li>初始化：向空的结果树T = (VT, ET)中添加G = (V, E)的任一顶点u0，使得VT = {u0}， ET = Ø</li>
<li>循环直到VT = V: 从G中选择满足{(u, v)|u∈VT， v∈V-VT}，且具有最小权值的边(u, v)，并置VT = VT ∪ {v}，ET = ET ∪ {(u, v)}</li>
</ol>
<h5 id="4312-具体实现">4.3.1.2 具体实现</h5>
<p>引入数组：<!-- raw HTML omitted -->
min_weight: 表示从已知顶点集VT到各顶点的最小权值<!-- raw HTML omitted -->
adjvex: 表示到达各顶点的最小权值的邻接顶点下标
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./%e5%9b%be%e9%99%84%e4%bb%b6/%e6%97%a0%e5%90%91%e5%b8%a6%e6%9d%83%e5%9b%be.png"
        data-srcset="./%e5%9b%be%e9%99%84%e4%bb%b6/%e6%97%a0%e5%90%91%e5%b8%a6%e6%9d%83%e5%9b%be.png, ./%e5%9b%be%e9%99%84%e4%bb%b6/%e6%97%a0%e5%90%91%e5%b8%a6%e6%9d%83%e5%9b%be.png 1.5x, ./%e5%9b%be%e9%99%84%e4%bb%b6/%e6%97%a0%e5%90%91%e5%b8%a6%e6%9d%83%e5%9b%be.png 2x"
        data-sizes="auto"
        alt="./图附件/无向带权图.png"
        title="无向带权图" /></p>
<ol>
<li>取A, 初始化数组:</li>
</ol>
<table>
<thead>
<tr>
<th>数组名</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>min_weight</td>
<td>0</td>
<td>3</td>
<td>1</td>
<td>INF</td>
<td>4</td>
</tr>
<tr>
<td>adjvex</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>取min(min_weight), 得 1 对应的边为 (A, C)，满足{(u, v)|u∈VT， v∈V-VT}（判断方法为min_weight[2] != 0），则min_weight[2] = 0，并更新数组</li>
</ol>
<table>
<thead>
<tr>
<th>数组名</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>min_weight</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>5</td>
<td>4</td>
</tr>
<tr>
<td>adjvex</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>0</td>
</tr>
</tbody>
</table>
<ol start="3">
<li>取min(min_weight), 得 2 对应的边为 (C, B)，满足{(u, v)|u∈VT， v∈V-VT}（判断方法为min_weight[1] != 0），则min_weight[1] = 0，并更新数组</li>
</ol>
<table>
<thead>
<tr>
<th>数组名</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>min_weight</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>5</td>
<td>4</td>
</tr>
<tr>
<td>adjvex</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>0</td>
</tr>
</tbody>
</table>
<ol start="4">
<li>取min(min_weight), 得 4 对应的边为 (A, E)，满足{(u, v)|u∈VT， v∈V-VT}（判断方法为min_weight[4] != 0），则min_weight[4] = 0，并更新数组</li>
</ol>
<table>
<thead>
<tr>
<th>数组名</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>min_weight</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>5</td>
<td>0</td>
</tr>
<tr>
<td>adjvex</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>0</td>
</tr>
</tbody>
</table>
<ol start="5">
<li>取min(min_weight), 得 5 对应的边为 (C, D)，满足{(u, v)|u∈VT， v∈V-VT}（判断方法为min_weight[3] != 0），则min_weight[3] = 0，并更新数组</li>
</ol>
<table>
<thead>
<tr>
<th>数组名</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>min_weight</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>adjvex</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>0</td>
</tr>
</tbody>
</table>
<h4 id="432-kruskal算法">4.3.2 Kruskal算法</h4>
<h5 id="4321-流程描述">4.3.2.1 流程描述</h5>
<ol>
<li>初始化: VT = V; ET = Ø</li>
<li>循环：按G的边权值递增一次从E-ET中选择边，若其加入后不构成回路，将其加入ET中，否则舍弃，直到|ET| = |V| - 1</li>
</ol>
<pre><code>MST_Kruskal(G, DSU)
    sort(G.edges)
    Init(DSU)
    for i = 0...G.edges.length
        if DSU.isSameGroup(edges[i].a, edges[i].b)
            continue;
        ET = ET ∪ {edges[i]}
        DSU.union(edges[i].a, edges[i].b)
</code></pre></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2021-03-15</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/redis/redis_java%E5%AE%A2%E6%88%B7%E7%AB%AF-jedis/" class="prev" rel="prev" title="Java客户端 Jedis与lettuce"><i class="fas fa-angle-left fa-fw"></i>Java客户端 Jedis与lettuce</a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.81.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/posts/" target="_blank">Riddle</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
